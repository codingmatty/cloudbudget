{"version":3,"sources":["../../src/auth/oauth2.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAKA,IAAM,qBAAqB,EAArB;;;AAGN,IAAM,SAAS,sBAAY,YAAZ,EAAT;;;;;;;;;;;;;;;AAeN,OAAO,eAAP,CAAuB,UAAC,MAAD,EAAS,IAAT,EAAkB;AACvC,SAAO,KAAK,IAAL,EAAW,OAAO,EAAP,CAAlB,CADuC;CAAlB,CAAvB;;AAIA,OAAO,iBAAP,CAAyB,UAAC,EAAD,EAAK,IAAL,EAAc;AACrC,aAAO,QAAP,CAAgB,EAAhB,EAAoB,UAAC,GAAD,EAAM,MAAN,EAAiB;AACnC,QAAI,GAAJ,EAAS;AAAE,aAAO,KAAK,GAAL,CAAP,CAAF;KAAT;AACA,WAAO,KAAK,IAAL,EAAW,MAAX,CAAP,CAFmC;GAAjB,CAApB,CADqC;CAAd,CAAzB;;;;;;;;;;;;;;;;AAqBA,OAAO,KAAP,CAAa,sBAAY,KAAZ,CAAkB,IAAlB,CAAuB,UAAC,MAAD,EAAS,WAAT,EAAsB,IAAtB,EAA4B,IAA5B,EAAkC,IAAlC,EAA2C;AAC7E,MAAM,aAAa,IAAI,gBAAM,QAAN,EAAjB,CADuE;AAE7E,qBAAmB,UAAnB,IAAiC;AAC/B,cAAU,OAAO,EAAP;AACV,4BAF+B;AAG/B,YAAQ,KAAK,EAAL;GAHV,CAF6E;AAO7E,OAAK,IAAL,EAAW,UAAX,EAP6E;CAA3C,CAApC;;;;;;;;;;;;;;;;;;;;;AA+BA,OAAO,QAAP,CAAgB,sBAAY,QAAZ,CAAqB,QAArB,CAA8B,UAAC,MAAD,EAAS,QAAT,EAAmB,QAAnB,EAA6B,KAA7B,EAAoC,IAApC,EAA6C;AACzF,aAAO,OAAP,CAAe,EAAE,UAAU,OAAO,QAAP,EAA3B,EAA8C,UAAC,aAAD,EAAgB,QAAhB,EAA6B;AACzE,QAAI,aAAJ,EAAmB;AAAE,aAAO,KAAK,aAAL,CAAP,CAAF;KAAnB;AACA,QAAI,CAAC,QAAD,EAAW;AAAE,aAAO,KAAK,IAAL,EAAW,KAAX,CAAP,CAAF;KAAf;AACA,QAAI,SAAS,YAAT,KAA0B,OAAO,YAAP,EAAqB;AAAE,aAAO,KAAK,IAAL,EAAW,KAAX,CAAP,CAAF;KAAnD;AACA,QAAI,CAAC,iBAAE,QAAF,CAAW,SAAS,WAAT,EAAsB,UAAjC,CAAD,EAA+C;AAAE,aAAO,KAAK,IAAL,EAAW,KAAX,CAAP,CAAF;KAAnD;AACA,QAAI,CAAC,QAAD,EAAW;AAAE,aAAO,KAAK,IAAL,EAAW,KAAX,CAAP,CAAF;KAAf;AACA,aAAK,OAAL,CAAa,EAAE,kBAAF,EAAb,EAA2B,UAAC,WAAD,EAAc,IAAd,EAAuB;AAChD,UAAI,WAAJ,EAAiB;AAAE,eAAO,KAAK,WAAL,CAAP,CAAF;OAAjB;AACA,UAAI,CAAC,IAAD,EAAO;AAAE,eAAO,KAAK,IAAL,EAAW,KAAX,CAAP,CAAF;OAAX;AACA,UAAI,CAAC,KAAK,cAAL,CAAoB,QAApB,CAAD,EAAgC;AAAE,eAAO,KAAK,IAAL,EAAW,KAAX,CAAP,CAAF;OAApC;AACA,sBAAY,MAAZ,CAAmB,iBAAE,KAAF,CAAQ;AACzB,kBAAU,OAAO,EAAP;AACV,gBAAQ,KAAK,EAAL;OAFS,EAGhB,gBAAY,cAAZ,EAHgB,CAAnB,EAGkC,UAAC,GAAD,EAAM,WAAN,EAAsB;AACtD,YAAI,GAAJ,EAAS;AAAE,iBAAO,KAAK,GAAL,CAAP,CAAF;SAAT;AACA,aAAK,IAAL,EAAW,YAAY,KAAZ,CAAX,CAFsD;OAAtB,CAHlC,CAJgD;KAAvB,CAA3B,CANyE;GAA7B,CAA9C,CADyF;CAA7C,CAA9C;;;;;;;;AA6BA,OAAO,QAAP,CAAgB,sBAAY,QAAZ,CAAqB,IAArB,CAA0B,UAAC,MAAD,EAAS,IAAT,EAAe,WAAf,EAA4B,IAA5B,EAAqC;AAC7E,MAAM,WAAW,mBAAmB,IAAnB,CAAX,CADuE;AAE7E,MAAI,CAAC,QAAD,EAAW;AAAE,WAAO,KAAK,IAAL,EAAW,KAAX,CAAP,CAAF;GAAf;AACA,MAAI,OAAO,EAAP,KAAc,SAAS,QAAT,EAAmB;AAAE,WAAO,KAAK,IAAL,EAAW,KAAX,CAAP,CAAF;GAArC;AACA,MAAI,CAAC,iBAAE,QAAF,CAAW,OAAO,WAAP,EAAoB,MAA/B,CAAD,EAAyC;AAAE,WAAO,KAAK,IAAL,EAAW,KAAX,CAAP,CAAF;GAA7C;AACA,MAAI,gBAAgB,SAAS,WAAT,EAAsB;AAAE,WAAO,KAAK,IAAL,EAAW,KAAX,CAAP,CAAF;GAA1C;AACA,SAAO,mBAAmB,IAAnB,CAAP,CAN6E;AAO7E,kBAAY,MAAZ,CAAmB,iBAAE,KAAF,CAAQ;AACzB,YAAQ,SAAS,MAAT;AACR,cAAU,SAAS,QAAT;GAFO,EAGhB,gBAAY,cAAZ,EAHgB,CAAnB,EAGkC,UAAC,OAAD,EAAU,WAAV,EAA0B;AAC1D,QAAI,OAAJ,EAAa;AAAE,aAAO,KAAK,OAAL,CAAP,CAAF;KAAb;AACA,SAAK,IAAL,EAAW,YAAY,KAAZ,CAAX,CAF0D;GAA1B,CAHlC,CAP6E;CAArC,CAA1C;;kBAiBe","file":"oauth2.js","sourcesContent":["import _ from 'lodash';\nimport oauth2orize from 'oauth2orize';\nimport { Types } from 'mongoose';\nimport { Client, AccessToken, User } from '../db';\n\nconst authorizationCodes = {};\n\n// create OAuth 2.0 server\nconst server = oauth2orize.createServer();\n\n// Register serialialization and deserialization functions.\n//\n// When a client redirects a user to user authorization endpoint, an\n// authorization transaction is initiated.  To complete the transaction, the\n// user must authenticate and approve the authorization request.  Because this\n// may involve multiple HTTP request/response exchanges, the transaction is\n// stored in the session.\n//\n// An application must supply serialization functions, which determine how the\n// client object is serialized into the session.  Typically this will be a\n// simple matter of serializing the client's ID, and deserializing by finding\n// the client by ID from the database.\n\nserver.serializeClient((client, done) => {\n  return done(null, client.id);\n});\n\nserver.deserializeClient((id, done) => {\n  Client.findById(id, (err, client) => {\n    if (err) { return done(err); }\n    return done(null, client);\n  });\n});\n\n// Register supported grant types.\n//\n// OAuth 2.0 specifies a framework that allows users to grant client\n// applications limited access to their protected resources.  It does this\n// through a process of the user granting access, and the client exchanging\n// the grant for an access token.\n\n// Grant authorization codes.  The callback takes the `client` requesting\n// authorization, the `redirectURI` (which is used as a verifier in the\n// subsequent exchange), the authenticated `user` granting access, and\n// their response, which contains approved scope, duration, etc. as parsed by\n// the application.  The application issues a code, which is bound to these\n// values, and will be exchanged for an access token.\n\nserver.grant(oauth2orize.grant.code((client, redirectURI, user, ares, done) => {\n  const authCodeId = new Types.ObjectId();\n  authorizationCodes[authCodeId] = {\n    clientId: client.id,\n    redirectURI,\n    userId: user.id\n  };\n  done(null, authCodeId);\n}));\n\n\n// server.exchange(oauth2orize.exchange.refreshToken((client, refreshToken, scope, done) => {\n//   AccessToken.remove({ refreshToken, clientId: client.clientId }, (err, token) => {\n//     if (err) { return done(err); }\n//     if (!token) { return done(null, false); }\n\n//     User.findById(token.userId, (err, user) => {\n//       if (err) { return done(err); }\n//       if (!user) { return done(null, false); }\n\n//       var model = {\n//         userId: user.userId,\n//         clientId: client.clientId\n//       };\n\n//       generateTokens(model, done);\n//     });\n//   });\n// }));\n\n\nserver.exchange(oauth2orize.exchange.password((client, username, password, scope, done) => {\n  Client.findOne({ clientId: client.clientId }, (findClientErr, dbClient) => {\n    if (findClientErr) { return done(findClientErr); }\n    if (!dbClient) { return done(null, false); }\n    if (dbClient.clientSecret !== client.clientSecret) { return done(null, false); }\n    if (!_.includes(dbClient.permissions, 'password')) { return done(null, false); }\n    if (!username) { return done(null, false); }\n    User.findOne({ username }, (findUserErr, user) => {\n      if (findUserErr) { return done(findUserErr); }\n      if (!user) { return done(null, false); }\n      if (!user.verifyPassword(password)) { return done(null, false); }\n      AccessToken.create(_.merge({\n        clientId: client.id,\n        userId: user.id\n      }, AccessToken.generateTokens()), (err, accessToken) => {\n        if (err) { return done(err); }\n        done(null, accessToken.token);\n      });\n    });\n  });\n}));\n\n\n// Exchange authorization codes for access tokens.  The callback accepts the\n// `client`, which is exchanging `code` and any `redirectURI` from the\n// authorization request for verification.  If these values are validated, the\n// application issues an access token on behalf of the user who authorized the\n// code.\n\nserver.exchange(oauth2orize.exchange.code((client, code, redirectURI, done) => {\n  const authCode = authorizationCodes[code];\n  if (!authCode) { return done(null, false); }\n  if (client.id !== authCode.clientId) { return done(null, false); }\n  if (!_.includes(client.permissions, 'code')) { return done(null, false); }\n  if (redirectURI !== authCode.redirectURI) { return done(null, false); }\n  delete authorizationCodes[code];\n  AccessToken.create(_.merge({\n    userId: authCode.userId,\n    clientId: authCode.clientId\n  }, AccessToken.generateTokens()), (saveErr, accessToken) => {\n    if (saveErr) { return done(saveErr); }\n    done(null, accessToken.token);\n  });\n}));\n\n\nexport default server;\n"]}