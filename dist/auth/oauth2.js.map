{"version":3,"sources":["../../src/auth/oauth2.js"],"names":[],"mappings":"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","file":"oauth2.js","sourcesContent":["import _ from 'lodash';\nimport oauth2orize from 'oauth2orize';\nimport { Types } from 'mongoose';\nimport { Client, AccessToken, User } from '../db';\n\nconst authorizationCodes = {};\n\n// create OAuth 2.0 server\nconst server = oauth2orize.createServer();\n\n// Register serialialization and deserialization functions.\n//\n// When a client redirects a user to user authorization endpoint, an\n// authorization transaction is initiated.  To complete the transaction, the\n// user must authenticate and approve the authorization request.  Because this\n// may involve multiple HTTP request/response exchanges, the transaction is\n// stored in the session.\n//\n// An application must supply serialization functions, which determine how the\n// client object is serialized into the session.  Typically this will be a\n// simple matter of serializing the client's ID, and deserializing by finding\n// the client by ID from the database.\n\nserver.serializeClient((client, done) => {\n  return done(null, client.id);\n});\n\nserver.deserializeClient((id, done) => {\n  Client.findById(id, (err, client) => {\n    if (err) { return done(err); }\n    return done(null, client);\n  });\n});\n\n// Register supported grant types.\n//\n// OAuth 2.0 specifies a framework that allows users to grant client\n// applications limited access to their protected resources.  It does this\n// through a process of the user granting access, and the client exchanging\n// the grant for an access token.\n\n// Grant authorization codes.  The callback takes the `client` requesting\n// authorization, the `redirectURI` (which is used as a verifier in the\n// subsequent exchange), the authenticated `user` granting access, and\n// their response, which contains approved scope, duration, etc. as parsed by\n// the application.  The application issues a code, which is bound to these\n// values, and will be exchanged for an access token.\n\nserver.grant(oauth2orize.grant.code((client, redirectURI, user, ares, done) => {\n  const authCodeId = new Types.ObjectId();\n  authorizationCodes[authCodeId] = {\n    clientId: client.id,\n    redirectURI,\n    userId: user.id\n  };\n  done(null, authCodeId);\n}));\n\n\n// server.exchange(oauth2orize.exchange.refreshToken((client, refreshToken, scope, done) => {\n//   AccessToken.remove({ refreshToken, clientId: client.clientId }, (err, token) => {\n//     if (err) { return done(err); }\n//     if (!token) { return done(null, false); }\n\n//     User.findById(token.userId, (err, user) => {\n//       if (err) { return done(err); }\n//       if (!user) { return done(null, false); }\n\n//       var model = {\n//         userId: user.userId,\n//         clientId: client.clientId\n//       };\n\n//       generateTokens(model, done);\n//     });\n//   });\n// }));\n\n\nserver.exchange(oauth2orize.exchange.password((client, username, password, scope, done) => {\n  Client.findOne({ clientId: client.clientId }, (findClientErr, dbClient) => {\n    if (findClientErr) { return done(findClientErr); }\n    if (!dbClient) { return done(null, false); }\n    if (dbClient.clientSecret !== client.clientSecret) { return done(null, false); }\n    if (!_.includes(dbClient.permissions, 'password')) { return done(null, false); }\n    if (!username) { return done(null, false); }\n    User.findOne({ username }, (findUserErr, user) => {\n      if (findUserErr) { return done(findUserErr); }\n      if (!user) { return done(null, false); }\n      if (!user.verifyPassword(password)) { return done(null, false); }\n      AccessToken.create(_.merge({\n        clientId: client.id,\n        userId: user.id\n      }, AccessToken.generateTokens()), (err, accessToken) => {\n        if (err) { return done(err); }\n        done(null, accessToken.token);\n      });\n    });\n  });\n}));\n\n\n// Exchange authorization codes for access tokens.  The callback accepts the\n// `client`, which is exchanging `code` and any `redirectURI` from the\n// authorization request for verification.  If these values are validated, the\n// application issues an access token on behalf of the user who authorized the\n// code.\n\nserver.exchange(oauth2orize.exchange.code((client, code, redirectURI, done) => {\n  const authCode = authorizationCodes[code];\n  if (!authCode) { return done(null, false); }\n  if (client.id !== authCode.clientId) { return done(null, false); }\n  if (!_.includes(client.permissions, 'code')) { return done(null, false); }\n  if (redirectURI !== authCode.redirectURI) { return done(null, false); }\n  delete authorizationCodes[code];\n  AccessToken.create(_.merge({\n    userId: authCode.userId,\n    clientId: authCode.clientId\n  }, AccessToken.generateTokens()), (saveErr, accessToken) => {\n    if (saveErr) { return done(saveErr); }\n    done(null, accessToken.token);\n  });\n}));\n\n\nexport default server;\n"]}